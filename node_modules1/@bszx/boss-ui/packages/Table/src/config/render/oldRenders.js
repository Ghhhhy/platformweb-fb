/*
 * @Description: 旧版渲染器，为了地方执行、指标账功能还在使用旧版渲染器，暂时保留；但新做功能需使用新渲染器
 * @Author: Comer
 * @Date: 2023-05-06 10:21:47
 * @LastEditors: Comer
 * @LastEditTime: 2023-05-06 10:21:49
 */
/* eslint-disable no-eval */
// 全局渲染器   Author:Titans@2396757591@qq.com
// cellRender渲染器名字配置
// autofocus 自动聚焦的类名
// renderHeader(h, renderOpts, params) 表头
// renderEdit(h, renderOpts, params) 表内容 - 编辑
// renderCell(h, renderOpts, params) 表内容 - 显示
// renderFooter(h, renderOpts, params) 表尾
// editCellExportMethod(params) 单元格导出函数
// footerCellExportMethod(params) 表尾单元格导出函数
const defaultGloabalUtils = {
  calculateRender(
    h,
    { props, name },
    {
      $columnIndex,
      $rowIndex,
      items,
      column,
      data,
      row,
      $seq,
      $table,
      $type,
      columnIndex,
      isEdit,
      level,
      rowIndex,
      seq
    },
    context
  ) {
    props = props || {}
    let val = isNaN(parseFloat(row[column.property]))
      ? ''
      : parseFloat(row[column.property])
    if (val !== '') {
      row[column.property] = val.toFixed(2)
      if (context.$grid.$parent.toolbarConfigInCopy.disabledMoneyConversion) {
        val = Number(val.toFixed(2)).toLocaleString()
        val =
          val.split('.').length === 1
            ? val + '.00'
            : val.split('.')[1].length === 1
              ? val + '0'
              : val
      } else {
        let moneyUnit = context.$grid.$parent.moneyUnit
          ? context.$grid.$parent.moneyUnit
          : 1
        val = Number((val / moneyUnit).toFixed(2)).toLocaleString()
        val =
          val.split('.').length === 1
            ? val + '.00'
            : val.split('.')[1].length === 1
              ? val + '0'
              : val
      }
      row[column.property + '__viewSort'] = val
      return [
        <span class="text" {...{ props }}>
          {val}
        </span>
      ]
    } else {
      row[column.property + '__viewSort'] = ''
      return [<span class="text" {...{ props }}></span>]
    }
  },
  calculateRender_old(
    h,
    renderOpts,
    {
      $columnIndex,
      $rowIndex,
      items,
      column,
      data,
      row,
      $seq,
      $grid,
      $table,
      $type,
      columnIndex,
      isEdit,
      level,
      rowIndex,
      seq
    },
    context
  ) {
    function calclate(columns, row, key) {
      function rever(columns) {
        columns.some((item, index) => {
          if (item.field === key && regR.test(item.formula)) {
            formulaItem = item
            return true
          }
          if (
            !formulaItem &&
            Array.isArray(item.children) &&
            item.children.length
          ) {
            rever(item.children)
          }
        })
      }
      let formulaItem = false
      let regR = new RegExp('({[a-zA-Z0-9_]*})', 'ig')
      rever(columns)
      if (formulaItem) {
        let formula = formulaItem.formula
        for (let keyC in row) {
          let reg = new RegExp('({' + keyC + '})', 'ig')
          if (reg.test(formula)) {
            calclate(items, row, keyC)
            let value =
              typeof row[keyC] === 'number' || typeof row[keyC] === 'string'
                ? row[keyC]
                : 0
            formula = formula.replace(
              reg,
              isNaN(parseFloat(value)) ? 0 : parseFloat(value)
            )
          }
        }
        if (regR.test(formula)) {
          formula = formula.replace(regR, 0)
          console.log(
            `计算时公式依赖的字段数值未定义可能导致计算有误,当前行数据为:${row},计算公式为:${formulaItem.formula}，替换值后公式为${formula}`
          )
        }
        row[key] = eval(formula).toFixed(2)
        // row[key] = parseFloat(row[key].split('.').length === 1 ? row[key] + '.00' : (row[key].split('.')[0].length === 1 ? row[key] + '0' : row[key]))
      }
      return row[key]
    }
    calclate(context.$grid.columns, row, column.property)
    let val = isNaN(parseFloat(row[column.property]))
      ? 0
      : parseFloat(row[column.property])
    if (context.$grid.$parent.toolbarConfigInCopy.disabledMoneyConversion) {
      val = Number(val.toFixed(2)).toLocaleString()
      val =
        val.split('.').length === 1
          ? val + '.00'
          : val.split('.')[1].length === 1
            ? val + '0'
            : val
      return [<span class="text">{val}</span>]
    } else {
      let moneyUnit = context.$grid.$parent.moneyUnit
        ? context.$grid.$parent.moneyUnit
        : 1
      val = Number((val / moneyUnit).toFixed(2)).toLocaleString()
      val =
        val.split('.').length === 1
          ? val + '.00'
          : val.split('.')[1].length === 1
            ? val + '0'
            : val
      return [<span>{val}</span>]
    }
  },
  calculateFooter(
    { columns, data, $table, $grid, columnIndexText, combinedType },
    context
  ) {
    // let moneyUnit = $grid.$parent.moneyUnit ? $grid.$parent.moneyUnit : 1
    // console.log(moneyUnit)
    return columns.map((column, columnIndex) => {
      //  combinedType: ['average', 'total'],
      // let combinedType = 'total'
      if (columnIndex === 0) {
        return columnIndexText
      } else if (
        column.own.combinedType === 'switchTotal' ||
        (column.own.combinedType + '').split(',').indexOf(combinedType) >= 0
      ) {
        try {
          let result = data.map((item, index) => {
            let value =
              typeof item[column.property] === 'number' ||
                typeof item[column.property] === 'string'
                ? parseFloat(
                  item[column.property]
                    .toString()
                    .split(',')
                    .join('')
                )
                : 0
            return isNaN(parseFloat(value)) ? 0 : parseFloat(value)
          })
          if (result.length) {
            result = result.reduce((prev, next) => {
              return prev + next
            })
            if (combinedType === 'average') {
              result = result / data.length
            }
            result = Number(result.toFixed(2)).toLocaleString()
            result =
              result.split('.').length === 1
                ? result + '.00'
                : result.split('.')[1].length === 1
                  ? result + '0'
                  : result
            return result
          } else {
            return '0.00'
          }
        } catch (e) {
          throw e
        }
      } else {
        return ''
      }
    })
  },
  calculateFooter_average({ columns, data, $table, $grid }) {
    // console.log(moneyUnit)
    return columns.map((column, columnIndex) => {
      //  combinedType: ['average', 'total'],
      // let combinedType = 'total'
      if (columnIndex === 0) {
        return '平均'
      } else if (
        column.own.combinedType === 'switchTotal' ||
        (column.own.combinedType + '').split(',').indexOf('average') >= 0
      ) {
        try {
          let result = data.map((item, index) => {
            let value =
              typeof item[column.property] === 'number' ||
                typeof item[column.property] === 'string'
                ? parseFloat(
                  item[column.property]
                    .toString()
                    .split(',')
                    .join('')
                )
                : 0
            return isNaN(parseFloat(value)) ? 0 : parseFloat(value)
          })
          if (result.length) {
            result = result.reduce((prev, next) => {
              return prev + next
            })
            result = result / data.length
            return result
          } else {
            return '0.00'
          }
        } catch (e) {
          throw e
        }
      } else {
        return ''
      }
    })
  },
  calculateFooter_subTotal({ columns, data, $table, $grid }) {
    // console.log(moneyUnit)
    let selections = $grid.getCheckboxRecords()
    return columns.map((column, columnIndex) => {
      //  combinedType: ['average', 'total'],
      // let combinedType = 'total'
      if (columnIndex === 0) {
        return '已选(' + $grid.getCheckboxRecords().length + ')'
      } else if (
        column.own.combinedType === 'switchTotal' ||
        (column.own.combinedType + '').split(',').indexOf('subTotal') >= 0
      ) {
        try {
          let result = selections.map((item, index) => {
            let value =
              typeof item[column.property] === 'number' ||
                typeof item[column.property] === 'string'
                ? parseFloat(
                  item[column.property]
                    .toString()
                    .split(',')
                    .join('')
                )
                : 0
            return isNaN(parseFloat(value)) ? 0 : parseFloat(value)
          })
          if (result.length) {
            result = result.reduce((prev, next) => {
              return prev + next
            })
            return result
          } else {
            return '0.00'
          }
        } catch (e) {
          throw e
        }
      } else {
        return ''
      }
    })
  },
  calculateFooter_total({ columns, data, $table, $grid }) {
    // console.log(moneyUnit)
    return columns.map((column, columnIndex) => {
      if (columnIndex === 0) {
        return '合计'
      } else if (
        column.own.combinedType === 'switchTotal' ||
        (column.own.combinedType + '').split(',').indexOf('total') >= 0
      ) {
        try {
          let result = data.map((item, index) => {
            let value =
              typeof item[column.property] === 'number' ||
                typeof item[column.property] === 'string'
                ? parseFloat(
                  item[column.property]
                    .toString()
                    .split(',')
                    .join('')
                )
                : 0
            return isNaN(parseFloat(value)) ? 0 : parseFloat(value)
          })
          if (result.length) {
            result = result.reduce((prev, next) => {
              return prev + next
            })
            return result
          } else {
            return '0.00'
          }
        } catch (e) {
          throw e
        }
      } else {
        return ''
      }
    })
  },
  calculateFooter_totalAll({ columns, data, $table, $grid }) {
    // console.log(moneyUnit)
    let item = $grid.$parent.footerConfigIn.totalObj || {}
    return columns.map((column, columnIndex) => {
      if (columnIndex === 0) {
        return '合计'
      } else if (
        column.own.combinedType === 'switchTotal' ||
        (column.own.combinedType + '').split(',').indexOf('total') >= 0
      ) {
        try {
          let result =
            typeof item[column.property] === 'number' ||
              typeof item[column.property] === 'string'
              ? parseFloat(
                item[column.property]
                  .toString()
                  .split(',')
                  .join('')
              )
              : 0
          return result
        } catch (e) {
          throw e
        }
      } else {
        return ''
      }
    })
  }
}
const cellRenderers = {
  // 全局渲染器
  // cellRender渲染器名字配置
  // autofocus 自动聚焦的类名
  // renderHeader(h, renderOpts, params) 表头
  // renderEdit(h, renderOpts, params) 表内容 - 编辑
  // renderCell(h, renderOpts, params) 表内容 - 显示
  // renderFooter(h, renderOpts, params) 表尾
  // editCellExportMethod(params) 单元格导出函数
  // footerCellExportMethod(params) 表尾单元格导出函数
  $vxeTableOptionRow: {
    // 操作列渲染
    renderDefault(h, renderOpts, params, context) {
      let self = context.$grid.$parent
      const { props } = renderOpts
      const { row, column } = params
      const { statusField, options } = props
      let renderOption = options[row[statusField]]
      if (renderOption) {
        return [
          <div class="row-option row-option-group">
            {
              renderOption.map((item, index) => {
                if (item.type === 'button') {
                  return <vxe-button class={item.class || ''} status={item.btnStatus} on-click={() => self.onOptionRowClick({ row, column, optionType: item.code })}>{item.label}</vxe-button>
                } else {
                  return <a class={'fn-inline f14 ' + item.class || 'fn-inline f14'} status={item.btnStatus} on-click={() => self.onOptionRowClick({ row, column, optionType: item.code })}>{item.label}</a>
                }
              })
            }
          </div>
        ]
      } else {
        return ''
      }
    }
  },
  NotData: {
    // 空内容模板
    renderEmpty(h, renderOpts) {
      return [
        <div>
          <span>
            <p>亲，没有更多数据了！</p>
          </span>
        </div>
      ]
    }
  },
  $calculateRender: {
    // 计算列
    // let row = {
    //   a: 1,
    //   b: 2,
    //   c: 3
    // }
    // let formula = 'Math.pow({a}+{b},{c})'
    // for (let k in row) {
    // let reg = new RegExp('({' + k + '})', 'ig')
    //   if (reg.test(formula)) {
    //     formula = formula.replace(reg, row[k])
    //   }
    // }
    // let calcResult = (new Function('console.log(formula);return eval(formula)'))()
    renderDefault(h, renderOpts, { $columnIndex, $rowIndex, items, column, data, row, $seq, $table, $type, columnIndex, isEdit, level, rowIndex, seq }, context) {
      return defaultGloabalUtils.calculateRender(h, renderOpts, { $columnIndex, $rowIndex, items, column, data, row, $seq, $table, $type, columnIndex, isEdit, level, rowIndex, seq }, context)
    },
    renderCell(h, renderOpts, { $columnIndex, $rowIndex, items, column, data, row, $seq, $table, $type, columnIndex, isEdit, level, rowIndex, seq }, context) {
      return defaultGloabalUtils.calculateRender(h, renderOpts, { $columnIndex, $rowIndex, items, column, data, row, $seq, $table, $type, columnIndex, isEdit, level, rowIndex, seq }, context)
    },
    renderEdit(h, renderOpts, { $columnIndex, $rowIndex, items, column, data, row, $seq, $table, $type, columnIndex, isEdit, level, rowIndex, seq }, context) {
      return defaultGloabalUtils.calculateRender(h, renderOpts, { $columnIndex, $rowIndex, items, column, data, row, $seq, $table, $type, columnIndex, isEdit, level, rowIndex, seq }, context)
      // return [
      //   <vxe-input
      //     v-model={row[column.property]}
      //     placeholder="自动计算"
      //     readonly
      //     clearable
      //   ></vxe-input>
      // ]
    }
  },
  $moneyRender: {
    // 输入框
    renderDefault(h, { props }, { row, column }, context) {
      props = props || {}
      let val = isNaN(parseFloat(row[column.property])) ? '' : parseFloat(row[column.property])
      if (val !== '') {
        row[column.property] = val.toFixed(2)
        if (context.$grid.$parent.toolbarConfigInCopy.disabledMoneyConversion) {
          val = Number((val).toFixed(2)).toLocaleString()
          val = val.split('.').length === 1 ? val + '.00' : (val.split('.')[1].length === 1 ? val + '0' : val)
          return [<span class="text" {...{ props }} >{val}</span>]
        } else {
          let moneyUnit = context.$grid.$parent.moneyUnit ? context.$grid.$parent.moneyUnit : 1
          val = Number((val / moneyUnit).toFixed(2)).toLocaleString()
          val = val.split('.').length === 1 ? val + '.00' : (val.split('.')[1].length === 1 ? val + '0' : val)
          return [<span class="text" {...{ props }} >{val}</span>]
        }
      } else {
        return [<span class="text" {...{ props }} ></span>]
      }
    },
    renderEdit(h, { props }, { row, column }) {
      // let val = isNaN(parseFloat(row[column.property])) ? '0.00' : parseFloat(row[column.property])
      // row[column.property] = val
      props = props || {}
      // <vxe-input v-model="value504" placeholder="小数间隔 2.3" type="float" step="2.3" clearable></vxe-input>
      return [
        <vxe-input
          v-model={row[column.property]}
          step={1}
          type="float"
          min={0.00}
          {...{ props }}
          max={1000000000000}
          placeholder="可清除"
          clearable
        ></vxe-input>
        // <input class="my-cell" text="text" v-model={ row[column.property] } />
      ]
    },
    renderCell(h, { props }, { row, column }, context) {
      props = props || {}
      let val = isNaN(parseFloat(row[column.property])) ? '' : parseFloat(row[column.property])
      if (val !== '') {
        row[column.property] = val.toFixed(2)
        if (context.$grid.$parent.toolbarConfigInCopy.disabledMoneyConversion) {
          val = Number((val).toFixed(2)).toLocaleString()
          val = val.split('.').length === 1 ? val + '.00' : (val.split('.')[1].length === 1 ? val + '0' : val)
          return [<span class="text" {...{ props }} >{val}</span>]
        } else {
          let moneyUnit = context.$grid.$parent.moneyUnit ? context.$grid.$parent.moneyUnit : 1
          val = Number((val / moneyUnit).toFixed(2)).toLocaleString()
          val = val.split('.').length === 1 ? val + '.00' : (val.split('.')[1].length === 1 ? val + '0' : val)
          return [<span class="text" {...{ props }} >{val}</span>]
        }
      } else {
        return [<span class="text" {...{ props }}></span>]
      }
    }
  },
  $treeText: {
    renderCell(h, cellRender, { row, column }, context) {
      const name = row[`${column.property}name`] === ' ' ? '' : row[`${column.property}name`]
      const code = row[`${column.property}code`] === ' ' ? '' : row[`${column.property}code`]
      const noCode = cellRender.props && cellRender.props.noCode
      const treelineData = cellRender.props && cellRender.props.treelineData
      let text = ''
      if (treelineData) {
        text = row[`${column.property}`] ? row[`${column.property}`] : ''
      } else {
        if (name) {
          text = noCode ? `${name}` : `${code}-${name}`
        }
      }

      return [<span class="text">{text}</span>]
    },
    renderEdit(h, cellRender, { row, column }, context) {
      const name = row[`${column.property}name`] === ' ' ? '' : row[`${column.property}name`]
      const code = row[`${column.property}code`] === ' ' ? '' : row[`${column.property}code`]
      const noCode = cellRender.props && cellRender.props.noCode
      let text = ''
      if (name) {
        text = noCode ? `${name}` : `${code}-${name}`
      }
      return [
        <vxe-input
          v-model={text}
          placeholder="自动计算"
          readonly
          clearable
        ></vxe-input>
      ]
      // return [<span class="text">{text}</span>]
    }
  },
  $treeinput: {
    renderCell(h, cellRender, { row, column, $rowIndex }, context) {
      // console.log('cell')
      // 2、反向给tree 3元素赋值
      let props = cellRender.props || {}
      let property = column.property
      props['prefix'] = property

      let timeStamp = +new Date()
      if (row[property]) {
        const valueArr = row[property].split('##')
        row[property + 'id'] = valueArr[0]
        row[property + 'code'] = valueArr[1]
        row[property + 'name'] = valueArr[2]
      }

      if (!row[property + 'id']) {
        row[property] = 'initId' + timeStamp + '## ## '
      } else {
        row[property] = row[property + 'id'] + '##' + row[property + 'code'] + '##' + row[property + 'name']
      }

      const name = row[`${column.property}name`]
      const code = row[`${column.property}code`]
      const noCode = cellRender.props && cellRender.props.noCode

      let text = ''
      if (name && name !== ' ') {
        text = noCode ? `${name}` : `${code}-${name}`
      }

      return [<span class="text" > {text} </span>]
    },
    renderEdit(h, cellRender, { row, column }, context) {
      // console.log('edit')
      try {
        let props = cellRender.props || {}
        let property = column.property
        let options = cellRender.options || []

        props['prefix'] = property
        let timeStamp = +new Date()
        // 1、正向给tree 3元素赋值
        if (!row[property + 'id']) {
          // 情况1:只给了前缀，没有给3个值，初始化3个值
          row[property + 'id'] = 'initId' + timeStamp
          row[property + 'code'] = ' '
          row[property + 'name'] = ' '
        } else {
          // 情况2: 给了前缀和id  code与name可能给了，可能没给； 给了的话优先用给了的值
          row[property + 'code'] = row[property + 'code'] || ' '
          row[property + 'name'] = row[property + 'name'] || ' '
        }

        // 2、反向给tree 3元素赋值
        if (row[property]) {
          const valueArr = row[property].split('##')
          row[property + 'id'] = valueArr[0]
          row[property + 'code'] = valueArr[1]
          row[property + 'name'] = valueArr[2]
        }

        // 转接串  1、3个树节点均没有  2、有3个树节点数据
        if (!row[property + 'id']) {
          row[property] = 'initId' + timeStamp + '## ## '
        } else {
          row[property] = row[property + 'id'] + '##' + row[property + 'code'] + '##' + row[property + 'name']
        }
        return [
          <BsTreeInput datas={options} v-model={row[column.property]} {...{ props }} ></BsTreeInput>
        ]
      } catch (e) { }
    }
  },
  $treeTextCheck: {
    renderCell(h, cellRender, { row, column }, context) {
      const name = row[`${column.property}name`] === ' ' ? '' : row[`${column.property}name`]
      const code = row[`${column.property}code`] === ' ' ? '' : row[`${column.property}code`]
      const noCode = cellRender.props && cellRender.props.noCode
      let text = ''
      if (name) {
        let names = name.split(',')
        let codes = code.split(',')
        let line = ''
        if (names.length === codes.length) {
          for (let i = 0, len = names.length; i < len; i++) {
            line += (noCode ? `${names[i]}` : `${codes[i]}-${names[i]}`)
            if (i < len - 1) {
              line += ','
            }
          }
        } else {
          console.log('table: code,name数量匹配不上')
        }
        text = line
      }
      return [<span class="text">{text}</span>]
    }
  },
  $treeinputCheck: {
    renderCell(h, cellRender, { row, column, $rowIndex }, context) {
      // console.log('cell')
      // 2、反向给tree 3元素赋值
      let props = cellRender.props || {}
      let property = column.property
      props['prefix'] = property

      let timeStamp = +new Date()
      if (row[property]) {
        const valueArr = row[property].split('##')
        row[property + 'id'] = valueArr[0]
        row[property + 'code'] = valueArr[1]
        row[property + 'name'] = valueArr[2]
      }

      if (!row[property + 'id']) {
        row[property] = 'initId' + timeStamp + '## ## '
      } else {
        row[property] = row[property + 'id'] + '##' + row[property + 'code'] + '##' + row[property + 'name']
      }

      const name = row[`${column.property}name`]
      const code = row[`${column.property}code`]
      const noCode = cellRender.props && cellRender.props.noCode

      let text = ''
      if (name && name !== ' ') {
        text = noCode ? `${name}` : `${code}-${name}`
      }

      return [<span class="text" > {text} </span>]
    },
    renderEdit(h, cellRender, { row, column }, context) {
      // console.log('edit')
      try {
        let props = cellRender.props || {}
        let property = column.property
        let options = cellRender.options || []

        props['prefix'] = property
        let timeStamp = +new Date()
        // 1、正向给tree 3元素赋值
        if (!row[property + 'id']) {
          // 情况1:只给了前缀，没有给3个值，初始化3个值
          row[property + 'id'] = 'initId' + timeStamp
          row[property + 'code'] = ' '
          row[property + 'name'] = ' '
        } else {
          // 情况2: 给了前缀和id  code与name可能给了，可能没给； 给了的话优先用给了的值
          row[property + 'code'] = row[property + 'code'] || ' '
          row[property + 'name'] = row[property + 'name'] || ' '
        }

        // 2、反向给tree 3元素赋值
        if (row[property]) {
          const valueArr = row[property].split('##')
          row[property + 'id'] = valueArr[0]
          row[property + 'code'] = valueArr[1]
          row[property + 'name'] = valueArr[2]
        }

        // 转接串  1、3个树节点均没有  2、有3个树节点数据
        if (!row[property + 'id']) {
          row[property] = 'initId' + timeStamp + '## ## '
        } else {
          row[property] = row[property + 'id'] + '##' + row[property + 'code'] + '##' + row[property + 'name']
        }
        return [
          <BsTreeInputTest datas={options} v-model={row[column.property]} {...{ props }} ></BsTreeInputTest>
        ]
      } catch (e) { }
    }
  },
  $EditDownTextarea: {
    autofocus: '.vxe-input--inner',
    renderEdit(h, renderOpts, params) {
      return [
        <edit-down-textarea params={params}></edit-down-textarea>
      ]
    },
    renderCell(h, cellRender, { row, column }, context) {
      return [<span class="text">{row[column.property]}</span>]
    }
  },
  $EditDownJson: {
    autofocus: '.vxe-input--inner',
    renderEdit(h, renderOpts, params) {
      return [
        <edit-down-json params={params}></edit-down-json>
      ]
    },
    // renderCell(h, renderOpts, params) {
    //   return [
    //     <edit-down-json params={ params }></edit-down-json>
    //   ]
    // }
    renderCell(h, cellRender, { row, column }, context) {
      let value = JSON.stringify(row[column.property])
      return [<span class="text">{value}</span>]
    }
  },
  $EditDownConditions: {
    autofocus: '.vxe-input--inner',
    renderEdit(h, { name, options, props }, params) {
      return [
        <edit-down-conditions constProps={props} params={params}></edit-down-conditions>
      ]
    },
    renderCell(h, cellRender, { row, column }, context) {
      return [<span class="text">{row[column.property]}</span>]
    }
  },
  $optionSort: {
    renderDefault(h, cellRender, { $columnIndex, $rowIndex, items, column, data, row, $seq, columnIndex, isEdit, level, rowIndex, seq }, { $excel, $grid, $table, $type }) {
      let self = $grid.$parent
      // <a class="optionRow" href={row.link}>{'操作' + row[column.property]}</a>
      return [
        <div class="row-dragsort-option row-option-group">
          <a class="optionRow-delete fn-inline" onClick={() => self.onOptionSortRowClick({ row, column, $rowIndex, data, items, optionType: 'upSort' })}>上移</a>
          <a class="optionRow-edit fn-inline" onClick={() => self.onOptionSortRowClick({ row, column, $rowIndex, data, items, optionType: 'downSort' })}>下移</a>
          <a class="optionRow-report fn-inline" onClick={() => self.onOptionSortRowClick({ row, column, $rowIndex, data, items, optionType: 'topSort' })}>置顶</a>
          <a class="optionRow-detail fn-inline" onClick={() => self.onOptionSortRowClick({ row, column, $rowIndex, data, items, optionType: 'bottomSort' })}>置底</a>
        </div>
      ]
    }
  },
  optionRow: {
    renderDefault(h, cellRender, { row, column }, context) {
      let self = context.$grid.$parent
      // <a class="optionRow" href={row.link}>{'操作' + row[column.property]}</a>
      if (row.status === 0) {
        return [
          <div class="row-option row-option-group">
            <a class="optionRow-delete fn-inline" onClick={() => self.onOptionRowClick({ row, column, optionType: 'delete' })}>删除</a>
            <a class="optionRow-edit fn-inline" onClick={() => self.onOptionRowClick({ row, column, optionType: 'edit' })}>编辑</a>
            <a class="optionRow-report fn-inline" onClick={() => self.onOptionRowClick({ row, column, optionType: 'report' })}>上报</a>
            <a class="optionRow-detail fn-inline" onClick={() => self.onOptionRowClick({ row, column, optionType: 'detail' })}>详情</a>
          </div>
        ]
      } else {
        return [
          <div class="row-option row-option-group">
            <a class="optionRow-delete fn-inline" onClick={() => self.onOptionRowClick({ row, column, optionType: 'delete' })}>删除</a>
            <a class="optionRow-detail fn-inline" onClick={() => self.onOptionRowClick({ row, column, optionType: 'detail' })}>详情</a>
          </div>
        ]
      }
    }
  },
  $span: {
    // 文本渲染
    renderCell(h, renderOpts, { row, column }) {
      return [<span>{row[column.property]}</span>]
    },
    renderEdit(h, renderOpts, { row, column }) {
      return [
        <vxe-input
          v-model={row[column.property]}
          placeholder="自动计算"
          readonly
          clearable
        ></vxe-input>
      ]
      // return [<span>{row[column.property]}</span>]
    }
  },
  $href: {
    // 文本渲染
    renderCell(h, renderOpts, { row, column }) {
      return [<span class="text href-a"><a>{row[column.property]}</a></span>]
    },
    renderEdit(h, renderOpts, { row, column }) {
      return [<span class="text href-a"><a>{row[column.property]}</a></span>]
    },
    renderDefault(h, renderOpts, { row, column }) {
      return [<span class="text href-a"><a>{row[column.property]}</a></span>]
    }
  },
  $vexDynamicSelect: {
    renderEdit(h, { props, options }, { row, column }, { $excel, $grid, $table, $type }) {
      row.options = row.options || []
      return [
        <vxe-select v-model={row[column.property]} placeholder="请选择">
          {row.options.map((item, index) => {
            return [
              <vxe-option
                value={item.value}
                label={item.label}
              ></vxe-option>
            ]
          })}
        </vxe-select>
      ]
    },
    renderDefault(h, cellRender, { row, column }, context) {
      return [<span>{row[column.property]}</span>]
    },
    renderCell(h, renderOpts, { row, column }) {
      return [<span>{row[column.property]}</span>]
    }
  },
  $contentTable: {
    renderExpand(h, { props }, { $columnIndex, $rowIndex, items, column, data, row, $seq, $table, $type, columnIndex, isEdit, level, rowIndex, seq }, context) {
      const tableConfig = {
        globalConfig: { // 全局默认渲染列配置
          // 全局配置
          checkType: '',
          seq: false
        }
      }
      return [
        <BsTable toolbarConfig={false} pagerConfig={false} tableConfig={tableConfig} {...{ props }} height="unset" tableColumnsConfig={row.childCols} tableData={row.childData}></BsTable>
      ]
    }
  }
}
export default {
  ...cellRenderers
}
